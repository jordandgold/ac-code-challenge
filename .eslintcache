[{"/Users/jordan.gold/code/ac-code-challenge/src/reportWebVitals.ts":"1","/Users/jordan.gold/code/ac-code-challenge/src/App.tsx":"2","/Users/jordan.gold/code/ac-code-challenge/src/components/ContactsList/ContactsList.tsx":"3","/Users/jordan.gold/code/ac-code-challenge/src/components/DataTable/DataTable.tsx":"4","/Users/jordan.gold/code/ac-code-challenge/src/index.tsx":"5"},{"size":425,"mtime":1607567714331,"results":"6","hashOfConfig":"7"},{"size":236,"mtime":1607573998184,"results":"8","hashOfConfig":"7"},{"size":4591,"mtime":1607576028721,"results":"9","hashOfConfig":"7"},{"size":4587,"mtime":1607574776337,"results":"10","hashOfConfig":"7"},{"size":500,"mtime":1607567714330,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"v8tps2",{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"18","messages":"19","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"20"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/jordan.gold/code/ac-code-challenge/src/reportWebVitals.ts",[],"/Users/jordan.gold/code/ac-code-challenge/src/App.tsx",[],"/Users/jordan.gold/code/ac-code-challenge/src/components/ContactsList/ContactsList.tsx",[],"/Users/jordan.gold/code/ac-code-challenge/src/components/DataTable/DataTable.tsx",["23"],"import { BindAll } from 'lodash-decorators'\nimport React from 'react'\nimport { FromServerContact } from '../../api/models/contacts'\nimport { FromServerContactTag, FromServerTag } from '../../api/models/contactTags'\nimport { FromServerGeoAddress, FromServerGeoIp } from '../../api/models/geoAddresses'\n\nimport './dataTable.scss'\n\ninterface DataTableProps {\n    contacts: FromServerContact[]\n    contactTags: FromServerContactTag[]\n    tags: FromServerTag[]\n    contactDeals: any[]\n    deals: any[]\n    geoIps: FromServerGeoIp[]\n    geoAddresses: FromServerGeoAddress[]\n}\n\n@BindAll()\nexport class DataTable extends React.Component<DataTableProps> {\n    render() {\n        return (\n            <table className=\"ac-data-table\">\n                <thead>\n                    <tr>\n                        <th>Contact Name</th>\n                        <th>Contact Tags</th>\n                        <th>Deals</th>\n                        {/* I am leaving off total value because I am honestly not sure what data to use for this\n                        I saw each contact had a scoreValues property, but every instance had an empty array */}\n                        {/* <th>Total Value</th> */}\n                        <th>Location</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    {this.renderRows()}\n                </tbody>\n            </table>\n        )\n    }\n\n    private renderRows(): JSX.Element[] {\n        const { contacts } = this.props\n\n        return contacts.map((contact) => {\n            const contactTags = this.getTags(contact.contactTags).join(', ');\n\n            // see comment about deals below\n            // const contactDeals = this.getDeals(contact.contactDeals).join(', ');\n\n            const location = this.getLocation(contact.geoIps).join(', ');\n\n            return (\n                <tr key={contact.id}>\n                    <td><a href=\"#\">{contact.firstName + ' ' + contact.lastName}</a></td>\n                    <td>{contactTags}</td>\n                    <td align=\"center\">{contact.contactDeals.length}</td>\n                    {/* Leaving off total value. See comments in ContactsList.tsx */}\n                    {/* <td></td> */}\n                    <td>{location}</td>\n                </tr>\n            )\n        })\n    }\n\n    // It appears, based on the tag data and relationship\n    // information I am receiving, this data is incomplete.\n    private getTags(tagIds: string[]): string[] {\n        const { contactTags, tags } = this.props\n\n        // match the contact tag IDs to tag IDs\n        const newTagIds = contactTags.filter(contactTag => {\n            return tagIds.indexOf(contactTag.id) !== -1;\n        }).map(contactTag => {\n            return contactTag.tag\n        })\n\n        // get the tag names\n        const tagNames = tags.filter(tag => {\n            return newTagIds.indexOf(tag.id) !== -1;\n        }).map(tag => {\n            return tag.tag\n        })\n\n        return tagNames\n    }\n\n    // Originally I thought we wanted the deal names. This block\n    // is no longer needed. I saw in the design system that the\n    // deal is just a number\n\n    // private getDeals(dealIds: string[]): string[] {\n    //     const { contactDeals, deals } = this.props\n\n    //     // match the contact tag IDs to tag IDs\n    //     const newDealIds = contactDeals.filter(contactDeal => {\n    //         return dealIds.indexOf(contactDeal.id) !== -1\n    //     }).map(contactDeal => {\n    //         return contactDeal.deal\n    //     })\n\n    //     // get the tag names\n    //     const dealNames = deals.filter(deal => {\n    //         return newDealIds.indexOf(deal.id) !== -1\n    //     }).map(deal => {\n    //         return deal.title\n    //     })\n\n    //     return dealNames\n    // }\n\n    private getLocation(geoIpsFromContact: string[]): string[] {\n        const { geoIps, geoAddresses } = this.props\n\n        // match the contact tag IDs to tag IDs\n        const newGeoIds = geoIps.filter(geoIp => {\n            return geoIpsFromContact.indexOf(geoIp.id) !== -1\n        }).map(geoIp => {\n            return geoIp.geoAddress\n        })\n\n        // assuming a contact can have multiple locations\n        // since contact.geoIps is an array (and plural)\n        const locations = geoAddresses.filter(geoAddress => {\n            return newGeoIds.indexOf(geoAddress.id) !== -1\n        })\n\n        const serializedLocations = locations.map(locationData => {\n            return `${locationData.city}, ${locationData.state}, ${locationData.country}`\n        })\n\n        return serializedLocations\n    }\n}","/Users/jordan.gold/code/ac-code-challenge/src/index.tsx",[],{"ruleId":"24","severity":1,"message":"25","line":55,"column":25,"nodeType":"26","endLine":55,"endColumn":37},"jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement"]